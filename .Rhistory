# Set current directory
setwd("~/Documents/INGE/MASTER/1ère\ MASTER/1er\ QUADRI/HDDA/Projects/Breast-cancer-supervised-classification/")
# Mahalanobis depth function
Compute_maha_depth <- function(x, mu=colMeans(x), sigma=cov(x), robust=FALSE){
if(robust == TRUE){
#Robust estimation of the covariance matrix
library(MASS)
estimator <- cov.rob(x, method = "mcd")
mu <- estimator$center
sigma <- estimator$cov
}
1/(1 + mahalanobis(x, mu,sigma))
}
# Load quantitative data
data <- read.table("data.csv", header=TRUE, sep=',')
data <- data[,1:9]
attach(data)
View(data)
#*******************QUESTION_1***************************
# Compute depth
maha_d <- Compute_maha_depth(data, robust=TRUE)
# Compute PCA with an estimated covariance matrix
pca <- princomp(data, cor=TRUE)
# Represent data on first principal plane with different ranks
plot(pca$scores[,1], pca$scores[,2],
main="Data on first principal plane with ranks",
xlab="First component",
ylab= "Second component",
col=topo.colors(length(unique(maha_d)))[as.factor(maha_d)])
maha_d <- Compute_maha_depth(data, robust=TRUE)
View(maha_d)
# Represent data on first principal plane with different ranks
rbPal <- colorRampPalette(c('red','black')) #Create a function to generate a continuous color palette
data$Col <- rbPal(10)[as.numeric(cut(data$maha_d,breaks = 10))]
plot(pca$scores[,1], pca$scores[,2],
main="Data on first principal plane with ranks",
xlab="First component",
ylab= "Second component",
col=data$Col)
# Represent data on first principal plane with different ranks
rbPal <- colorRampPalette(c('red','black')) #Create a function to generate a continuous color palette
data$Col <- rbPal(10)[as.numeric(cut(as.factor(maha_d),breaks = 10))]
plot(pca$scores[,1], pca$scores[,2],
main="Data on first principal plane with ranks",
xlab="First component",
ylab= "Second component",
col=data$Col)
# Represent data on first principal plane with different ranks
plot(pca$scores[,1], pca$scores[,2],
main="Data on first principal plane with ranks",
xlab="First component",
ylab= "Second component",
col=heat.colors(length(unique(maha_d)))[as.factor(maha_d)])
install.packages("RColorBrewer")
install.packages("RColorBrewer")
# Represent data on first principal plane with different ranks
library("RColorBrewer")
grad_col <- brewer.pal(n=length(unique(maha_d)), name='YlOrRd')[as.factor(maha_d)]
#grad_col <- heat.colors(length(unique(maha_d)))[as.factor(maha_d)]
plot(pca$scores[,1], pca$scores[,2],
main="Data on first principal plane with ranks",
xlab="First component",
ylab= "Second component",
col=grad_col)
# Represent data on first principal plane with different ranks
library("RColorBrewer")
grad_col <- brewer.pal(n=116, name='YlOrRd')[as.factor(maha_d)]
#grad_col <- heat.colors(length(unique(maha_d)))[as.factor(maha_d)]
plot(pca$scores[,1], pca$scores[,2],
main="Data on first principal plane with ranks",
xlab="First component",
ylab= "Second component",
col=grad_col)
grad_col <- cm.colors(length(unique(maha_d)))[as.factor(maha_d)]
plot(pca$scores[,1], pca$scores[,2],
main="Data on first principal plane with ranks",
xlab="First component",
ylab= "Second component",
col=grad_col)
grad_col <- rainbow.colors(length(unique(maha_d)))[as.factor(maha_d)]
plot(pca$scores[,1], pca$scores[,2],
main="Data on first principal plane with ranks",
xlab="First component",
ylab= "Second component",
col=grad_col)
grad_col <- colorRampPalette(c('red','orange'))(length(unique(maha_d)))[as.factor(maha_d)]
plot(pca$scores[,1], pca$scores[,2],
main="Data on first principal plane with ranks",
xlab="First component",
ylab= "Second component",
col=grad_col)
grad_col <- colorRampPalette(c('orange','red'))(length(unique(maha_d)))[as.factor(maha_d)]
plot(pca$scores[,1], pca$scores[,2],
main="Data on first principal plane with ranks",
xlab="First component",
ylab= "Second component",
col=grad_col)
grad_col <- colorRampPalette(c('orange','red'))(length(unique(maha_d)))[as.factor(maha_d)]
plot(pca$scores[,1], pca$scores[,2],
main="Data on first principal plane with ranks",
xlab="First component",
ylab= "Second component",
pch=12,
col=grad_col)
plot(pca$scores[,1], pca$scores[,2],
main="Data on first principal plane with ranks",
xlab="First component",
ylab= "Second component",
pch=16,
col=grad_col)
grad_col <- colorRampPalette(c('yellow','red'))(length(unique(maha_d)))[as.factor(maha_d)]
plot(pca$scores[,1], pca$scores[,2],
main="Data on first principal plane with ranks",
xlab="First component",
ylab= "Second component",
pch=16,
col=grad_col)
# Represent data on first principal plane with different ranks
grad_col <- colorRampPalette(c('#FFCC00','#990000'))(length(unique(maha_d)))[as.factor(maha_d)]
plot(pca$scores[,1], pca$scores[,2],
main="Data on first principal plane with ranks",
xlab="First component",
ylab= "Second component",
pch=16,
col=grad_col)
# Represent data on first principal plane with different ranks
grad_col <- colorRampPalette(c('#FFCC00','#FF0000'))(length(unique(maha_d)))[as.factor(maha_d)]
plot(pca$scores[,1], pca$scores[,2],
main="Data on first principal plane with ranks",
xlab="First component",
ylab= "Second component",
pch=16,
col=grad_col)
# Represent data on first principal plane with different ranks
grad_col <- colorRampPalette(c('#FFFF00','#FF0000'))(length(unique(maha_d)))[as.factor(maha_d)]
plot(pca$scores[,1], pca$scores[,2],
main="Data on first principal plane with ranks",
xlab="First component",
ylab= "Second component",
pch=16,
col=grad_col)
# Represent data on first principal plane with different ranks
color_pal <- colorRampPalette(c('yellow','red'))
grad_col <- color_pal(length(unique(maha_d)))[as.factor(maha_d)]
plot(pca$scores[,1], pca$scores[,2],
main="Data on first principal plane with ranks",
xlab="First component",
ylab= "Second component",
pch=16,
col=grad_col)
legend("topright",title="Ranks",legend=c(1:3),col=color_pal(length(unique(maha_d))),pch=20)
# Represent data on first principal plane with different ranks
color_pal <- colorRampPalette(c('yellow','red'))
grad_col <- color_pal(length(unique(maha_d)))[as.factor(maha_d)]
plot(pca$scores[,1], pca$scores[,2],
main="Data on first principal plane with ranks",
xlab="First component",
ylab= "Second component",
pch=16,
col=grad_col)
legend("topright",title="Ranks",legend=c(1:3),col=color_pal(3),pch=20)
# Represent data on first principal plane with different ranks
color_pal <- colorRampPalette(c('yellow','red'))
grad_col <- color_pal(length(unique(maha_d)))[as.factor(maha_d)]
plot(pca$scores[,1], pca$scores[,2],
main="Quantitative data on first principal plane",
xlab="First component",
ylab= "Second component",
pch=20,
col=grad_col)
legend("topright",title="Ranks",legend=c("Small depht", "", "Big depth"),col=color_pal(3),pch=20)
# Represent data on first principal plane with different ranks
color_pal <- colorRampPalette(c('yellow','red'))
grad_col <- color_pal(length(unique(maha_d)))[as.factor(maha_d)]
plot(pca$scores[,1], pca$scores[,2],
main="Quantitative data on first principal plane",
xlab="First component",
ylab= "Second component",
pch=20,
col=grad_col)
legend("topright",title="Depth",legend=c("Small", "Medium", "Big"),col=color_pal(3),pch=20)
View(data)
# Add the Mahalanobis depths to the data
detach(data)
data$depth <- maha_d
attach(data)
View(data)
# Analysis of the deepest point and extreme cases
summary(data[which(Depth > 0.42),])
summary(data[which(Depth < 0.03),])
# Add the Mahalanobis depths to the data
detach(data)
data$Depth <- maha_d
attach(data)
View(data)
# Analysis of the deepest point and extreme cases
summary(data[which(Depth > 0.42),])
summary(data[which(Depth < 0.03),])
summary(data)
quantile(data$Depth, probs = c(0.05, 0.95))
summary(data$Depth)
quantile(data$Depth, probs = c(0.05, 0.95))
summary(data[which(Depth > 0.257),])
summary(data[which(Depth < .000375),])
clear
clr
summary(data$Depth)
quantile(data$Depth, probs = c(0.05, 0.95))
summary(data[which(Depth > 0.257),])
summary(data[which(Depth < .000375),])
quantile(data$Depth, probs = c(0.01, 0.99))
quantile(data$Depth, probs = c(0.01, 0.999999))
quantile(data$Depth, probs = c(0.02, 0.98))
summary(data[which(Depth > quantile(data$Depth, probs=0.02)),])
quantile(data$Depth, probs = c(0.01, 0.99))
quantile(data$Depth, probs = c(0.05, 0.95))
summary(data[which(Depth > quantile(data$Depth, probs=0.95)),])
summary(data[which(Depth > quantile(data$Depth, probs=0.05)),])
summary(data[which(Depth < quantile(data$Depth, probs=0.05)),])
summary(data[which(Depth > quantile(data$Depth, probs=0.95)),])
# Take the two most important variables
var1 <- data$BMI
var2_ <- data$Glucose
# Compute the Tukey depths
library(depth)
tukey_var1 <- apply(var1, 1, function(u){depth(u,var1, method = "Tukey")})
tukey_var2 <- apply(var2, 1, function(u){depth(u,var2, method = "Tukey")})
# Bagplot
bag <- bagplot(BMI,Glucose)
title(main = "Bagplot", xlab = "BMI", ylab = "Glucose", line = 2)
# Bagplot
library(aplpack)
bag <- bagplot(BMI,Glucose)
title(main = "Bagplot", xlab = "BMI", ylab = "Glucose", line = 2)
# Bagplot
library(aplpack)
bag <- bagplot(BMI,Glucose)
title(main = "Bagplot", xlab = "BMI", ylab = "Glucose", line = 2)
install.packages("aplpack")
# Bagplot
library(aplpack)
bag <- bagplot(BMI,Glucose)
title(main = "Bagplot", xlab = "BMI", ylab = "Glucose", line = 2)
install.packages("tcltk")
# Bagplot
library(aplpack)
bag <- bagplot(BMI,Glucose)
title(main = "Bagplot", xlab = "BMI", ylab = "Glucose", line = 2)
# Bagplot
library(aplpack)
bag <- bagplot(BMI,Glucose)
title(main = "Bagplot", xlab = "BMI", ylab = "Glucose", line = 5)
# Bagplot
library(aplpack)
bag <- bagplot(BMI,Glucose)
title(main = "Bagplot", xlab = "BMI", ylab = "Glucose", line = 1)
# Bagplot
library(aplpack)
bag <- bagplot(BMI,Glucose)
title(main = "Bagplot", xlab = "BMI", ylab = "Glucose", line = 2)
bag$hdepths
# Get the 2D rankings
TwoD_ranks <- bag$hdepths
# Measure the discrepancy between the 2D-ranking and the
# multivariate ranking of Q1 with Spearman rank correlation
corr_2D_ND <- corr(TwoD_ranks, maha_ND_ranks, method='spearman')
# Get the 2D rankings
TwoD_ranks <- bag$hdepths
# Measure the discrepancy between the 2D-ranking and the
# multivariate ranking of Q1 with Spearman rank correlation
library(MASS)
corr_2D_ND <- corr(TwoD_ranks, maha_ND_ranks, method='spearman')
install.packages("MASS")
install.packages("MASS")
# Get the 2D rankings
TwoD_ranks <- bag$hdepths
# Measure the discrepancy between the 2D-ranking and the
# multivariate ranking of Q1 with Spearman rank correlation
library(MASS)
corr_2D_ND <- corr(TwoD_ranks, maha_ND_ranks, method='spearman')
# Get the 2D rankings
TwoD_ranks <- bag$hdepths
# Measure the discrepancy between the 2D-ranking and the
# multivariate ranking of Q1 with Spearman rank correlation
library(MASS)
corr_2D_ND <- cor(TwoD_ranks, maha_ND_ranks, method='spearman')
# Set current directory
setwd("~/Documents/INGE/MASTER/1ère\ MASTER/1er\ QUADRI/HDDA/Projects/Breast-cancer-supervised-classification/")
# Load quantitative data
data <- read.table("data.csv", header=TRUE, sep=',')
data <- data[,1:9]
attach(data)
View(data)
#*******************QUESTION_1***************************
# Mahalanobis depth function
Compute_maha_depth <- function(x, mu=colMeans(x), sigma=cov(x), robust=FALSE){
if(robust == TRUE){
#Robust estimation of the covariance matrix
library(MASS)
estimator <- cov.rob(x, method = "mcd")
mu <- estimator$center
sigma <- estimator$cov
}
1/(1 + mahalanobis(x, mu,sigma))
}
# Compute depth
maha_ND_ranks <- Compute_maha_depth(data, robust=TRUE)
View(maha_ND_ranks)
# Compute PCA with an estimated covariance matrix
pca <- princomp(data, cor=TRUE)
# Represent data on first principal plane with different ranks
color_pal <- colorRampPalette(c('yellow','red'))
grad_col <- color_pal(length(unique(maha_ND_ranks)))[as.factor(maha_ND_ranks)]
plot(pca$scores[,1], pca$scores[,2],
main="Quantitative data on first principal plane",
xlab="First component",
ylab= "Second component",
pch=20,
col=grad_col)
legend("topright",title="Depth",legend=c("Small", "Medium", "Big"),col=color_pal(3),pch=20)
# Add the Mahalanobis depths to the data
detach(data)
data$Depth <- maha_ND_ranks
attach(data)
View(data)
# Analysis of the deepest point and extreme cases
summary(data$Depth)
quantile(data$Depth, probs = c(0.05, 0.95))
summary(data[which(Depth > quantile(data$Depth, probs=0.95)),])
summary(data[which(Depth < quantile(data$Depth, probs=0.05)),])
#*******************QUESTION_3***************************
# Bagplot
library(aplpack)
bag <- bagplot(BMI,Glucose)
title(main = "Bagplot", xlab = "BMI", ylab = "Glucose", line = 2)
# Get the 2D rankings
TwoD_ranks <- bag$hdepths
# Measure the discrepancy between the 2D-ranking and the
# multivariate ranking of Q1 with Spearman rank correlation
library(MASS)
corr_2D_ND <- cor(TwoD_ranks, maha_ND_ranks, method='spearman')
corr_2D_ND
library(MASS)
corr_2D_ND <- cor.test(TwoD_ranks, maha_ND_ranks, method='spearman')
corr_2D_ND
# Bagplot
library(aplpack)
bag <- bagplot(BMI,Glucose,main = "Bagplot", xlab = "BMI", ylab = "Glucose", line = 2)
# Bagplot
library(aplpack)
bag <- bagplot(BMI,Glucose,main = "Bagplot", xlab = "BMI", ylab = "Glucose")
#title(main = "Bagplot", xlab = "BMI", ylab = "Glucose", line = 2)
# Compute the Tukey depths
library(depth)
OneD_ranks_var1 <- apply(var1, 1, function(u){depth(u,var1, method = "Tukey")})
OneD_ranks_var2 <- apply(var2, 1, function(u){depth(u,var2, method = "Tukey")})
install.packages("depth")
# Compute the Tukey depths
library(depth)
OneD_ranks_var1 <- apply(var1, 1, function(u){depth(u,var1, method = "Tukey")})
OneD_ranks_var2 <- apply(var2, 1, function(u){depth(u,var2, method = "Tukey")})
# Take the two most important variables
var1 <- data$BMI
var2 <- data$Glucose
# Compute the Tukey depths
library(depth)
OneD_ranks_var1 <- apply(var1, 1, function(u){depth(u,var1, method = "Tukey")})
OneD_ranks_var2 <- apply(var2, 1, function(u){depth(u,var2, method = "Tukey")})
# Take the two most important variables
var1 <- data$BMI
var2 <- data$Glucose
# Compute the Tukey depths
library(depth)
OneD_ranks_var1 <- apply(var1, 1, function(u){depth(u,var1, method = "Tukey")})
OneD_ranks_var2 <- apply(var2, 1, function(u){depth(u,var2, method = "Tukey")})
var1
# Depth function using center-outward procedure from median
compute_1D_center_depth <- function(x){
# Get the median value of vector x
med <- median(x)
# Substract the median to each value
abs(x-median)
}
# Take the two most important variables
var1 <- data$BMI
var2 <- data$Glucose
# Compute the 1D-ranks
OneD_ranks_var1 <- compute_1D_center_depth(var1)
OneD_ranks_var2 <- compute_1D_center_depth(var2)
#*******************QUESTION_2***************************
# Depth function using center-outward procedure from median
compute_1D_center_depth <- function(x){
# Get the median value of vector x
med <- median(x)
# Substract the median to each value
x-median
}
# Take the two most important variables
var1 <- data$BMI
var2 <- data$Glucose
# Compute the 1D-ranks
OneD_ranks_var1 <- compute_1D_center_depth(var1)
OneD_ranks_var2 <- compute_1D_center_depth(var2)
# Depth function using center-outward procedure from median
compute_1D_center_depth <- function(x){
# Get the median value of vector x
med <- median(x)
# Substract the median to each value
x-med
}
# Take the two most important variables
var1 <- data$BMI
var2 <- data$Glucose
# Compute the 1D-ranks
OneD_ranks_var1 <- compute_1D_center_depth(var1)
OneD_ranks_var2 <- compute_1D_center_depth(var2)
# Depth function using center-outward procedure from median
compute_1D_center_depth <- function(x){
# Get the median value of vector x
med <- median(x)
# Substract the median to each value
abs(x-med)
}
# Take the two most important variables
var1 <- data$BMI
var2 <- data$Glucose
# Compute the 1D-ranks
OneD_ranks_var1 <- compute_1D_center_depth(var1)
OneD_ranks_var2 <- compute_1D_center_depth(var2)
OneD_ranks_var1
TwoD_ranks
median(var1)
